#pragma once
#include <array>
#include <bit>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstring>
#include <list>
#include <sstream>
#include <vector>

#define MAX_PLY 125
#define BENCH_DEPTH 13

// Random big num
#ifdef _MSC_VER
    #include <__msvc_int128.hpp>
using u128 = std::_Unsigned128;
#else
using u128 = unsigned __int128;
#endif

//#define TUNE
// #define LMR_TUNE

// Struct for tunable parameters
struct TunableParam {
        std::string name;
        int value;
        int defaultValue;
        int min;
        int max;
        int step;
};

// History Constants
constexpr int16_t MAX_HISTORY = 16383;
const int16_t DEFAULT_HISTORY = 0;
constexpr int CORR_HIST_ENTRIES = 16384;
constexpr int PAWN_HIST_ENTRIES = 1024;
constexpr int MAX_CORR_HIST = 1024;
// NNUE Parameters
constexpr int16_t HL_N = 1024;
constexpr int16_t QA = 255;
constexpr int16_t QB = 64;
constexpr int16_t NNUE_SCALE = 400;
constexpr int OUTPUT_BUCKETS = 8;

// Factorized LMR arrays
// {isQuiet, !isPV, improving, cutnode, ttpv, tthit, failhigh > 2}
const int LMR_ONE_COUNT = 7;
const int LMR_TWO_COUNT = LMR_ONE_COUNT * (LMR_ONE_COUNT - 1) / 2;
const int LMR_THREE_COUNT = LMR_ONE_COUNT * (LMR_ONE_COUNT - 1) * (LMR_ONE_COUNT - 2) / 6;
extern std::array<int, LMR_ONE_COUNT> LMR_ONE_PAIR;
extern std::array<int, LMR_TWO_COUNT> LMR_TWO_PAIR;
extern std::array<int, LMR_THREE_COUNT> LMR_THREE_PAIR;

// HL Corrhist Randoms
const std::array<uint64_t, 128> HL_CORRHIST_ZOBRIST = {0x1C80317FA3B1799D, 0xBDD640FB06671AD1, 0x3EB13B9046685257, 0x23B8C1E9392456DE, 0x1A3D1FA7BC8960A9, 0xBD9C66B3AD3C2D6D, 0x8B9D2434E465E150, 0x972A846916419F82, 0x0822E8F36C031199, 0x17FC695A07A0CA6E, 0x3B8FAA1837F8A88B, 0x9A1DE644815EF6D1, 0x8FADC1A606CB0FB3, 0xB74D0FB132E70629, 0xB38A088CA65ED389, 0x6B65A6A48B8148F6, 0x72FF5D2A386ECBE0, 0x4737819096DA1DAC, 0xDE8A774BCF36D58B, 0xC241330B01A9E71F, 0x28DF6EC4CE4A2BBD, 0x6C307511B2B9437A, 0x47229389571AA876, 0x371ECD7B27CD8130, 0xC37459EEF50BEA63, 0x1A2A73ED562B0F79, 0x6142EA7D17BE3111, 0x5BE6128E18C26797, 0x580D7B71D8F56413, 0x43B7A3A69A8DCA03, 0x0B1F9163CE9FF57F, 0x759CDE66BACFB3D0, 0x1FF49B7889463E85, 0xEC1B8CA1F91E1D4C, 0x142C3FE860E7A113, 0x4B0DBB418D5288F1, 0xA0EE89AED453DD32, 0xE2ACF72F9E574F7A, 0x5C941CF0DC98D2C1, 0x3139D32C93CD59BF, 0x11CE5DD2B45ED1F0, 0xA9488D990BBB2599, 0xC5E7CE8A3A578A8E, 0xFC377A4C4A15544D, 0xDAF61A26146D3F31, 0xDDD1DFB23B982EF8, 0x614FF3D719DB3AD0, 0x7412B29347294739, 0xD58842DEA2BC372F, 0x29A3B2E95D65A441, 0x5AF305535EC42E08, 0xAB9099A435A240AE, 0xB3AA7EFE4458A885, 0xAEFCFAD8EFC89849, 0x12476F57A5E5A5AB, 0xA28DEFE39BF00273, 0x88BD64072BCFBE01, 0x3EABEDCBBAA80DD4, 0x7656AF7229D4BEEF, 0x451B4CF36123FDF7, 0xECE66FA2FD5166E6, 0xB02B61C4A3D70628, 0x3838B3268E944239, 0x5304317FAF42E12F, 0xC4B032CCD7C524A5, 0x0E51F30DC6A7EE39, 0xD261A7AB3AA2E4F9, 0xCE177B4E0837B8A3, 0x66B2BC5B50C187FC, 0x10F1BC81448AAA9E, 0xE9C349E03602F8AC, 0x9132B63EF16287E4, 0xB7C93ACFE059A0EE, 0x366EB16F508EBAD7, 0x7FCD9EB1A7CAD415, 0xE27A984D654821D0, 0xA491F0B2EA1FCA65, 0x24933B83757750A9, 0x23BED01D43CF2FDE, 0xBEB799193F22FAF8, 0x89FA6A688FB5D27B, 0xBF3C4C06434308BC, 0x6DADD6C795A76D79, 0x956269F0E5D7B875, 0x5CABCC97663F1C97, 0xFF50BDE4382567B8, 0x2369B584FF5E9FF0, 0x7E570DDF827050A8, 0xC17AF08A1745D6D8, 0xDC713D960C0FD195, 0x27209BDF1C11F735, 0x28F49481A0A04DC4, 0xAE340454CAC5B68C, 0x98AE43346C12ACE8, 0x62801C4510435A10, 0x988C24C961B1CD22, 0x77D21E02FF01CF99, 0x405CACEC877409A9, 0x8DA0365BF89897B9, 0xF143262FDC5C0EED, 0xAE270DA702F06B90, 0x1D53434BB88139B9, 0xE2817EFDAE849217, 0xC03987108976E334, 0xC4C2E2E3444EA7C8, 0x5715BD6FA4161293, 0x4B22D3081C8EAEE9, 0x287D06CA6F4CC69A, 0x00D4AF5974273CA3, 0xB8DB0672F42D47CC, 0xB83CFE0BE037E5ED, 0xF8CDA88B436D76E2, 0xC30FF46E8026695F, 0x81F76D1C2DBC2134, 0x1B3DBD5CE9A1FA6F, 0xA013AC6EDEDA4E16, 0xD777A4774C66E0A8, 0x81F631D4A39231A7, 0x32EBD6899BE578C7, 0x5FB8D16C2720797D, 0x295B4715C333E861, 0xF4188F3F8A14BE62, 0xEC24A3C5C754108F, 0xEB2263DD87C5421E, 0x99546EB400257AD1, 0x7D15438552FBE43B, 0x1CA35CFB04FC6D82, 0x5CEC4EB5EDD96831};


std::list<TunableParam>& tunables();
TunableParam& addTunableParam(std::string name, int value, int min, int max, int step);
int lmrConvolution(std::array<bool, LMR_ONE_COUNT> features);
void printOBConfig();
void printWeatherFactoryConfig();

#define TUNABLE_PARAM(name, val, min, max, step)                                                                       \
    inline TunableParam& name##Param = addTunableParam(#name, val, min, max, step);                                    \
    inline int name() {                                                                                                \
        return name##Param.value;                                                                                      \
    }

// History Parameters
TUNABLE_PARAM(PAWN_CORR_WEIGHT, 210, 64, 2048, 32)
TUNABLE_PARAM(MAJOR_CORR_WEIGHT, 141, 64, 2048, 32)
TUNABLE_PARAM(MINOR_CORR_WEIGHT, 150, 64, 2048, 32)
TUNABLE_PARAM(NON_PAWN_STM_CORR_WEIGHT, 159, 64, 2048, 32)
TUNABLE_PARAM(NON_PAWN_NSTM_CORR_WEIGHT, 163, 64, 2048, 32)
TUNABLE_PARAM(WHITE_HL_CORRHIST_WEIGHT, 128, 64, 2048, 32)
TUNABLE_PARAM(CONT_CORR_WEIGHT, 147, 64, 2048, 32)
TUNABLE_PARAM(CORRHIST_BONUS_WEIGHT, 92, 10, 300, 10);

TUNABLE_PARAM(HIST_BONUS_QUADRATIC, 7, 1, 10, 1)
TUNABLE_PARAM(HIST_BONUS_LINEAR, 276, 64, 384, 32);
TUNABLE_PARAM(HIST_BONUS_OFFSET, 138, 64, 768, 64);

TUNABLE_PARAM(HIST_MALUS_QUADRATIC, 6, 1, 10, 1)
TUNABLE_PARAM(HIST_MALUS_LINEAR, 275, 64, 384, 32);
TUNABLE_PARAM(HIST_MALUS_OFFSET, 197, 64, 768, 64);

// Time Management
TUNABLE_PARAM(NODE_TM_BASE, 161, 30, 200, 5)
TUNABLE_PARAM(NODE_TM_SCALE, 141, 30, 200, 5)
TUNABLE_PARAM(COMPLEXITY_TM_SCALE, 82, 30, 200, 5)
TUNABLE_PARAM(COMPLEXITY_TM_BASE, 76, 30, 200, 5)
TUNABLE_PARAM(COMPLEXITY_TM_DIVISOR, 391, 200, 800, 10)

// SEE
TUNABLE_PARAM(PAWN_VALUE, 98, 50, 200, 7)
TUNABLE_PARAM(KNIGHT_VALUE, 324, 300, 700, 25)
TUNABLE_PARAM(BISHOP_VALUE, 323, 300, 700, 25)
TUNABLE_PARAM(ROOK_VALUE, 508, 400, 1000, 30)
TUNABLE_PARAM(QUEEN_VALUE, 999, 800, 1600, 40)

// Search Parameters
TUNABLE_PARAM(RFP_SCALE, 77, 30, 100, 8);
TUNABLE_PARAM(RFP_CORRPLEXITY_SCALE, 60, 16, 128, 5);

TUNABLE_PARAM(RAZORING_SCALE, 305, 100, 350, 40);

TUNABLE_PARAM(NMP_BASE_REDUCTION, 5, 2, 5, 1);
TUNABLE_PARAM(NMP_REDUCTION_SCALE, 3, 3, 6, 1);
TUNABLE_PARAM(NMP_EVAL_SCALE, 213, 50, 300, 10);

TUNABLE_PARAM(HIST_PRUNING_SCALE, 2501, 512, 4096, 64)

TUNABLE_PARAM(FP_SCALE, 146, 30, 200, 8)
TUNABLE_PARAM(FP_OFFSET, 92, 60, 350, 16)
TUNABLE_PARAM(FP_HIST_DIVISOR, 309, 128, 512, 16)

TUNABLE_PARAM(BNFP_DEPTH_SCALE, 122, 30, 200, 8)
TUNABLE_PARAM(BNFP_MOVECOUNT_SCALE, 366, 150, 500, 12)

TUNABLE_PARAM(SE_BETA_SCALE, 30, 8, 64, 1);
TUNABLE_PARAM(SE_DOUBLE_MARGIN, 21, 0, 40, 2);

// LMR Table
TUNABLE_PARAM(LMR_BASE_QUIET, 141, -50, 200, 5);
TUNABLE_PARAM(LMR_DIVISOR_QUIET, 273, 150, 350, 5);
TUNABLE_PARAM(LMR_BASE_NOISY, 24, -50, 200, 5);
TUNABLE_PARAM(LMR_DIVISOR_NOISY, 333, 150, 350, 5);
// Reduction Constants
TUNABLE_PARAM(LMR_HIST_DIVISOR, 8922, 4096, 16385, 650);
TUNABLE_PARAM(LMR_BASE_SCALE, 1058, 256, 2048, 64)
// Deeper/Shallower
TUNABLE_PARAM(LMR_DEEPER_BASE, 36, 16, 64, 4)
TUNABLE_PARAM(LMR_DEEPER_SCALE, 3, 3, 12, 1)

TUNABLE_PARAM(SEE_NOISY_SCALE, -86, -128, -16, 16)
TUNABLE_PARAM(SEE_QUIET_SCALE, -74, -128, -16, 16)
TUNABLE_PARAM(QS_SEE_MARGIN, 8, -2000, 200, 30)

TUNABLE_PARAM(MIN_ASP_WINDOW_DEPTH, 3, 3, 8, 1);
TUNABLE_PARAM(INITIAL_ASP_WINDOW, 31, 8, 64, 4);
TUNABLE_PARAM(ASP_WIDENING_FACTOR, 4, 1, 32, 2);