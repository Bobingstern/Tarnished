#pragma once
#include <array>
#include <bit>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstring>
#include <list>
#include <sstream>
#include <vector>

#define MAX_PLY 125
#define BENCH_DEPTH 13

// Random big num
#ifdef _MSC_VER
    #include <__msvc_int128.hpp>
using u128 = std::_Unsigned128;
#else
using u128 = unsigned __int128;
#endif

//#define TUNE
// #define LMR_TUNE

// Struct for tunable parameters
struct TunableParam {
        std::string name;
        int value;
        int defaultValue;
        int min;
        int max;
        int step;
};

// History Constants
constexpr int16_t MAX_HISTORY = 16383;
const int16_t DEFAULT_HISTORY = 0;
constexpr int CORR_HIST_ENTRIES = 16384;
constexpr int PAWN_HIST_ENTRIES = 1024;
constexpr int MAX_CORR_HIST = 1024;
// NNUE Parameters
constexpr int16_t HL_N = 1024;
constexpr int16_t QA = 255;
constexpr int16_t QB = 64;
constexpr int16_t NNUE_SCALE = 400;
constexpr int OUTPUT_BUCKETS = 8;
const bool HORIZONTAL_MIRROR = true;

// Factorized LMR arrays
// {isQuiet, !isPV, improving, cutnode, ttpv, tthit, failhigh > 2}
const int LMR_ONE_COUNT = 7;
const int LMR_TWO_COUNT = LMR_ONE_COUNT * (LMR_ONE_COUNT - 1) / 2;
const int LMR_THREE_COUNT = LMR_ONE_COUNT * (LMR_ONE_COUNT - 1) * (LMR_ONE_COUNT - 2) / 6;
extern std::array<int, LMR_ONE_COUNT> LMR_ONE_PAIR;
extern std::array<int, LMR_TWO_COUNT> LMR_TWO_PAIR;
extern std::array<int, LMR_THREE_COUNT> LMR_THREE_PAIR;

// RFP Network
const double RFP_H1[16][5] = {
    {0.010941497050225735, 0.3668871223926544, -0.12267611175775528, -0.8515105843544006, 0.13309206068515778}, {-0.07791159301996231, 0.011092371307313442, 0.054879993200302124, -1.1098551750183105, -0.2788655757904053}, {0.21838271617889404, -0.16851595044136047, -0.15947936475276947, -1.5519849061965942, -0.1872667521238327}, {-0.17290954291820526, 0.3630886971950531, -0.06472483277320862, -0.7362834811210632, 0.33868277072906494}, {-1.045542597770691, -0.11744163185358047, 0.12129006534814835, -0.06286527216434479, 0.026934130117297173}, {0.03388815000653267, -0.15639474987983704, -0.015720698982477188, -1.9087008237838745, 0.19646593928337097}, {-0.01357518695294857, 0.3445962369441986, 0.13746188580989838, 0.4036098122596741, -0.32366943359375}, {0.22897842526435852, 0.4564591348171234, -0.12398827075958252, 1.2314069271087646, 0.36681079864501953}, {0.4730474352836609, 0.1489211469888687, 0.25135818123817444, -0.9167155623435974, -0.16159212589263916}, {-0.16639235615730286, 0.21109707653522491, -0.054388370364904404, -0.7917605638504028, 0.3306519091129303}, {-1.1467418670654297, 0.10064980387687683, 0.342253178358078, 0.33883044123649597, 0.07809891551733017}, {-0.38555383682250977, 0.14196091890335083, 0.008312244899570942, 0.46979448199272156, -0.214734748005867}, {0.1354360431432724, -0.3298358619213104, -0.3467842936515808, 1.2977759838104248, 0.5659013390541077}, {0.5875439047813416, 0.11940193176269531, -0.0016946634277701378, 1.4681023359298706, -0.12912330031394958}, {-0.15942230820655823, -0.3093163073062897, -0.27969497442245483, 1.1919969320297241, -0.029110781848430634}, {-0.418959379196167, 0.14285840094089508, 0.20279137790203094, 0.8897169828414917, -0.42140892148017883}
};
const double RFP_H1_BIAS[16] = {-0.5474568009376526, 0.7014182806015015, -0.7267180681228638, 0.2754588723182678, -1.0752615928649902, -1.0242950916290283, -0.5681479573249817, -0.07419779151678085, 0.2989010214805603, 0.24822907149791718, -0.39037612080574036, 0.11534769833087921, 0.9064898490905762, 0.7412045001983643, 1.3313080072402954, -0.36750882863998413};
const double RFP_OUTPUT[16] = {-0.09882622957229614, -0.045198194682598114, -0.015430258587002754, -0.12369102239608765, 0.07182911783456802, -0.12302267551422119, 0.006741328630596399, 0.17781990766525269, -0.11749724298715591, -0.03556332737207413, 0.04654776677489281, 0.010706774890422821, 0.017835263162851334, 0.1855628788471222, 0.02419900707900524, 0.02849515713751316};
const double RFP_OUTPUT_BIAS = 0.5200806260108948;
const double RFP_THREHOLD = 1.586; // Sigmoid threhold is 0.83, just solve for sigmoid(x) > 0.83


std::list<TunableParam>& tunables();
TunableParam& addTunableParam(std::string name, int value, int min, int max, int step);
int lmrConvolution(std::array<bool, LMR_ONE_COUNT> features);
bool rfpInference(int depth, int eval, int beta, bool improving, int corrplexity);
void printOBConfig();
void printWeatherFactoryConfig();

#define TUNABLE_PARAM(name, val, min, max, step)                                                                       \
    inline TunableParam& name##Param = addTunableParam(#name, val, min, max, step);                                    \
    inline int name() {                                                                                                \
        return name##Param.value;                                                                                      \
    }

// History Parameters
TUNABLE_PARAM(PAWN_CORR_WEIGHT, 210, 64, 2048, 32)
TUNABLE_PARAM(MAJOR_CORR_WEIGHT, 141, 64, 2048, 32)
TUNABLE_PARAM(MINOR_CORR_WEIGHT, 150, 64, 2048, 32)
TUNABLE_PARAM(NON_PAWN_STM_CORR_WEIGHT, 159, 64, 2048, 32)
TUNABLE_PARAM(NON_PAWN_NSTM_CORR_WEIGHT, 163, 64, 2048, 32)
TUNABLE_PARAM(CONT_CORR_WEIGHT, 147, 64, 2048, 32)
TUNABLE_PARAM(CORRHIST_BONUS_WEIGHT, 92, 10, 300, 10);

TUNABLE_PARAM(HIST_BONUS_QUADRATIC, 7, 1, 10, 1)
TUNABLE_PARAM(HIST_BONUS_LINEAR, 276, 64, 384, 32);
TUNABLE_PARAM(HIST_BONUS_OFFSET, 138, 64, 768, 64);

TUNABLE_PARAM(HIST_MALUS_QUADRATIC, 6, 1, 10, 1)
TUNABLE_PARAM(HIST_MALUS_LINEAR, 275, 64, 384, 32);
TUNABLE_PARAM(HIST_MALUS_OFFSET, 197, 64, 768, 64);

// Time Management
TUNABLE_PARAM(NODE_TM_BASE, 161, 30, 200, 5)
TUNABLE_PARAM(NODE_TM_SCALE, 141, 30, 200, 5)
TUNABLE_PARAM(COMPLEXITY_TM_SCALE, 82, 30, 200, 5)
TUNABLE_PARAM(COMPLEXITY_TM_BASE, 76, 30, 200, 5)
TUNABLE_PARAM(COMPLEXITY_TM_DIVISOR, 391, 200, 800, 10)

// SEE
TUNABLE_PARAM(PAWN_VALUE, 98, 50, 200, 7)
TUNABLE_PARAM(KNIGHT_VALUE, 324, 300, 700, 25)
TUNABLE_PARAM(BISHOP_VALUE, 323, 300, 700, 25)
TUNABLE_PARAM(ROOK_VALUE, 508, 400, 1000, 30)
TUNABLE_PARAM(QUEEN_VALUE, 999, 800, 1600, 40)

// Search Parameters
TUNABLE_PARAM(RFP_SCALE, 77, 30, 100, 8);
TUNABLE_PARAM(RFP_CORRPLEXITY_SCALE, 60, 16, 128, 5);

TUNABLE_PARAM(RAZORING_SCALE, 305, 100, 350, 40);

TUNABLE_PARAM(NMP_BASE_REDUCTION, 5, 2, 5, 1);
TUNABLE_PARAM(NMP_REDUCTION_SCALE, 3, 3, 6, 1);
TUNABLE_PARAM(NMP_EVAL_SCALE, 213, 50, 300, 10);

TUNABLE_PARAM(HIST_PRUNING_SCALE, 2501, 512, 4096, 64)

TUNABLE_PARAM(FP_SCALE, 146, 30, 200, 8)
TUNABLE_PARAM(FP_OFFSET, 92, 60, 350, 16)
TUNABLE_PARAM(FP_HIST_DIVISOR, 309, 128, 512, 16)

TUNABLE_PARAM(BNFP_DEPTH_SCALE, 122, 30, 200, 8)
TUNABLE_PARAM(BNFP_MOVECOUNT_SCALE, 366, 150, 500, 12)

TUNABLE_PARAM(SE_BETA_SCALE, 30, 8, 64, 1);
TUNABLE_PARAM(SE_DOUBLE_MARGIN, 21, 0, 40, 2);

// LMR Table
TUNABLE_PARAM(LMR_BASE_QUIET, 141, -50, 200, 5);
TUNABLE_PARAM(LMR_DIVISOR_QUIET, 273, 150, 350, 5);
TUNABLE_PARAM(LMR_BASE_NOISY, 24, -50, 200, 5);
TUNABLE_PARAM(LMR_DIVISOR_NOISY, 333, 150, 350, 5);
// Reduction Constants
TUNABLE_PARAM(LMR_HIST_DIVISOR, 8922, 4096, 16385, 650);
TUNABLE_PARAM(LMR_BASE_SCALE, 1058, 256, 2048, 64)
// Deeper/Shallower
TUNABLE_PARAM(LMR_DEEPER_BASE, 36, 16, 64, 4)
TUNABLE_PARAM(LMR_DEEPER_SCALE, 3, 3, 12, 1)

TUNABLE_PARAM(SEE_NOISY_SCALE, -86, -128, -16, 16)
TUNABLE_PARAM(SEE_QUIET_SCALE, -74, -128, -16, 16)
TUNABLE_PARAM(QS_SEE_MARGIN, 8, -2000, 200, 30)

TUNABLE_PARAM(MIN_ASP_WINDOW_DEPTH, 3, 3, 8, 1);
TUNABLE_PARAM(INITIAL_ASP_WINDOW, 31, 8, 64, 4);
TUNABLE_PARAM(ASP_WIDENING_FACTOR, 4, 1, 32, 2);